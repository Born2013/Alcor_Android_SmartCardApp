#define LOG_TAG "BIRD_DEVICE_TEST"#include <jni.h>#include <stdio.h>#include <stdlib.h>#include <sys/ioctl.h>#include <sys/types.h>#include <sys/stat.h>#include <fcntl.h>#include <unistd.h>#include <pthread.h>#include <ctype.h>#include <errno.h>#include <getopt.h>#include <limits.h>#include <linux/input.h>#include <string.h>#include <sys/reboot.h>#include <sys/types.h>#include <time.h>#include <cutils/properties.h>#include <utils/Log.h>#include <android/log.h>#define LED_BRIGHTNESS_PATH_R "/sys/class/leds/red/brightness"#define LED_BRIGHTNESS_PATH_G "/sys/class/leds/green/brightness"#define LED_BRIGHTNESS_PATH_B "/sys/class/leds/blue/brightness"#define KPD_BKL_PATH		"/sys/class/leds/button-backlight/brightness"#define	BREATHLED_NAME "/dev/breathled"#define ENABLE_VIBRATOR 	4#define DISABLE_VIBRATOR 	5#define __DEBUG				0#define BUF_LEN 16#ifdef _cplusplusextern "C" {#endifint getBarcode(char *result){	const int BUF_SIZE = 128;	char buf[BUF_SIZE];	const int HALT_TIME = 100 * 1000;	int fd = -1;        //LOGE("getBarcode");	fd = open("/dev/ttyC0", O_RDWR);	if(fd < 0) {		//LOGE("Fail to open device: %s\n", strerror(errno));                //LOGE("getBarcode open fail");		return fd;	}	strcpy(buf, "AT+EGMR=0,5\r\n");	write(fd, buf, strlen(buf));	usleep(HALT_TIME);	read(fd, buf, BUF_SIZE);	char *p = NULL;	//const char *tok = "+EGMR: ";	//p = strstr(buf, tok);	p = strchr(buf, '\"'); // find the first double quotation mark.	if(p) {		strcpy(result, ++p);	} else {		strcpy(result, "unknow\n");	}        //LOGE("getBarcode result=%s",result);	return 0;}jstring barcode_bird(JNIEnv *env, jobject thiz){    char barcode[200]={0};    unsigned short barcode_w[200]={0};    getBarcode(barcode);for(int i=0;i<200;i++){barcode_w[i] = barcode[i];}    jstring barcode_s = env->NewString((jchar*)barcode_w,strlen(barcode));    return barcode_s;}    jboolean led_r_turn_on(JNIEnv *env, jobject thiz)    {        int fd = -1;        int ret = 0;        int level =255;        char wbuf[BUF_LEN] = {'\0'};        char rbuf[BUF_LEN] = {'\0'};        //LOGE("led_r_turn_on\n");        fd = open(LED_BRIGHTNESS_PATH_R, O_RDWR, 0);        if (fd == -1)        {            //LOGE("Can't open %s\n", LED_BRIGHTNESS_PATH_R);            return false;        }        sprintf(wbuf, "%d\n", level);        if (write(fd, wbuf, strlen(wbuf)) == -1)        {            //LOGE("Can't write %s\n", LED_BRIGHTNESS_PATH_R);            goto EXIT;        }        close(fd);        fd = open(LED_BRIGHTNESS_PATH_R, O_RDWR, 0);        if (fd == -1)        {            //LOGE("Can't open %s\n", LED_BRIGHTNESS_PATH_R);            goto EXIT;        }        if (read(fd, rbuf, BUF_LEN) == -1)        {            //LOGE("Can't read %s\n", LED_BRIGHTNESS_PATH_R);            goto EXIT;        }        if (!strncmp(wbuf, rbuf, BUF_LEN))            ret = true;EXIT:        if (fd != -1)            close(fd);        return JNI_TRUE;    }    jboolean led_r_turn_off(JNIEnv *env, jobject thiz)    {        int fd = -1;        int ret = 0;        int level =0;        char wbuf[BUF_LEN] = {'\0'};        char rbuf[BUF_LEN] = {'\0'};        //LOGE("led_r_turn_off\n");        fd = open(LED_BRIGHTNESS_PATH_R, O_RDWR, 0);        if (fd == -1)        {            //LOGE("Can't open %s\n", LED_BRIGHTNESS_PATH_R);            return false;        }        sprintf(wbuf, "%d\n", level);        if (write(fd, wbuf, strlen(wbuf)) == -1)        {           // LOGE("Can't write %s\n", LED_BRIGHTNESS_PATH_R);            goto EXIT;        }        close(fd);        fd = open(LED_BRIGHTNESS_PATH_R, O_RDWR, 0);        if (fd == -1)        {           // LOGE("Can't open %s\n", LED_BRIGHTNESS_PATH_R);            goto EXIT;        }        if (read(fd, rbuf, BUF_LEN) == -1)        {           // LOGE("Can't read %s\n", LED_BRIGHTNESS_PATH_R);            goto EXIT;        }        if (!strncmp(wbuf, rbuf, BUF_LEN))            ret = true;EXIT:        if (fd != -1)            close(fd);        return JNI_TRUE;    }//green led    jboolean led_g_turn_on(JNIEnv *env, jobject thiz)    {        int fd = -1;        int ret = 0;        int level =255;        char wbuf[BUF_LEN] = {'\0'};        char rbuf[BUF_LEN] = {'\0'};        //LOGE("led_r_turn_on\n");        fd = open(LED_BRIGHTNESS_PATH_G, O_RDWR, 0);        if (fd == -1)        {            return false;        }        sprintf(wbuf, "%d\n", level);        if (write(fd, wbuf, strlen(wbuf)) == -1)        {            goto EXIT;        }        close(fd);        fd = open(LED_BRIGHTNESS_PATH_G, O_RDWR, 0);        if (fd == -1)        {            goto EXIT;        }        if (read(fd, rbuf, BUF_LEN) == -1)        {            goto EXIT;        }        if (!strncmp(wbuf, rbuf, BUF_LEN))            ret = true;EXIT:        if (fd != -1)            close(fd);        return JNI_TRUE;    }    jboolean led_g_turn_off(JNIEnv *env, jobject thiz)    {        int fd = -1;        int ret = 0;        int level =0;        char wbuf[BUF_LEN] = {'\0'};        char rbuf[BUF_LEN] = {'\0'};        //LOGE("led_r_turn_off\n");        fd = open(LED_BRIGHTNESS_PATH_G, O_RDWR, 0);        if (fd == -1)        {            return false;        }        sprintf(wbuf, "%d\n", level);        if (write(fd, wbuf, strlen(wbuf)) == -1)        {            goto EXIT;        }        close(fd);        fd = open(LED_BRIGHTNESS_PATH_G, O_RDWR, 0);        if (fd == -1)        {            goto EXIT;        }        if (read(fd, rbuf, BUF_LEN) == -1)        {            goto EXIT;        }        if (!strncmp(wbuf, rbuf, BUF_LEN))            ret = true;EXIT:        if (fd != -1)            close(fd);        return JNI_TRUE;    }//blue led    jboolean led_b_turn_on(JNIEnv *env, jobject thiz)    {        int fd = -1;        int ret = 0;        int level =255;        char wbuf[BUF_LEN] = {'\0'};        char rbuf[BUF_LEN] = {'\0'};        //LOGE("led_r_turn_on\n");        fd = open(LED_BRIGHTNESS_PATH_B, O_RDWR, 0);        if (fd == -1)        {            return false;        }        sprintf(wbuf, "%d\n", level);        if (write(fd, wbuf, strlen(wbuf)) == -1)        {            goto EXIT;        }        close(fd);        fd = open(LED_BRIGHTNESS_PATH_B, O_RDWR, 0);        if (fd == -1)        {            goto EXIT;        }        if (read(fd, rbuf, BUF_LEN) == -1)        {            goto EXIT;        }        if (!strncmp(wbuf, rbuf, BUF_LEN))            ret = true;EXIT:        if (fd != -1)            close(fd);        return JNI_TRUE;    }    jboolean led_b_turn_off(JNIEnv *env, jobject thiz)    {        int fd = -1;        int ret = 0;        int level =0;        char wbuf[BUF_LEN] = {'\0'};        char rbuf[BUF_LEN] = {'\0'};        //LOGE("led_r_turn_off\n");        fd = open(LED_BRIGHTNESS_PATH_B, O_RDWR, 0);        if (fd == -1)        {            return false;        }        sprintf(wbuf, "%d\n", level);        if (write(fd, wbuf, strlen(wbuf)) == -1)        {            goto EXIT;        }        close(fd);        fd = open(LED_BRIGHTNESS_PATH_B, O_RDWR, 0);        if (fd == -1)        {            goto EXIT;        }        if (read(fd, rbuf, BUF_LEN) == -1)        {            goto EXIT;        }        if (!strncmp(wbuf, rbuf, BUF_LEN))            ret = true;EXIT:        if (fd != -1)            close(fd);        return JNI_TRUE;    }    jboolean keypad_bk_turn_on(JNIEnv *env, jobject thiz)    {        int r;        int kpd_fd = -1;      //  LOGE("keypad_bk_turn_on\n");        kpd_fd = open(KPD_BKL_PATH, O_WRONLY);        if (kpd_fd < 0)        {           // LOGE("kpd: open %s failed\n", KPD_BKL_PATH);            return JNI_FALSE;        }        if (write(kpd_fd,"1",1) == -1)        {         //  LOGE("Can't write\n");            return JNI_FALSE;        }        return JNI_TRUE;    }    jboolean keypad_bk_turn_off(JNIEnv *env, jobject thiz)    {        int r;        int kpd_fd = -1;     //   LOGE("keypad_bk_turn_off\n");        kpd_fd = open(KPD_BKL_PATH, O_WRONLY);        if (kpd_fd < 0)        {           // LOGE("kpd: open %s failed\n", KPD_BKL_PATH);            return JNI_FALSE;        }        if (write(kpd_fd,"0",1) == -1)        {     //       LOGE("Can't write\n");            return JNI_FALSE;        }        return JNI_TRUE;    }jboolean BreathledStart(JNIEnv *env, jobject thiz){	int res = 0;	int fd=0;	char buf[4];	fd = open(BREATHLED_NAME, O_RDWR);	buf[0]='1';        res = write(fd,buf,1);__android_log_print(ANDROID_LOG_INFO, "xu", "BreathledStart");		if(fd != -1)    {       close(fd) ;       fd = -1;    }		if (res < 0)	{		return JNI_FALSE;	}		if(buf[0] == 'A')	{	    return JNI_TRUE;	}	else	{	    return JNI_FALSE;	}    	}jboolean BreathledStop(JNIEnv *env, jobject thiz){	int res = 0;	int fd=0;	char buf[4];	fd = open(BREATHLED_NAME, O_RDWR);	buf[0]='2';        res = write(fd,buf,1);		if(fd != -1)    {       close(fd) ;       fd = -1;    }		if (res < 0)	{		return JNI_FALSE;	}		if(buf[0] == 'B')	{	    return JNI_TRUE;	}	else	{	    return JNI_FALSE;	}    	}jboolean Breathled1(JNIEnv *env, jobject thiz){	int res = 0;	int fd=0;	char buf[4];	fd = open(BREATHLED_NAME, O_RDWR);	//__android_log_print(ANDROID_LOG_INFO, "xu", "Breathled1 fd = "+fd);	buf[0]='1';        res = write(fd,buf,1);__android_log_print(ANDROID_LOG_INFO, "xu", "Breathled1");		if(fd != -1)    {       close(fd) ;       fd = -1;    }__android_log_print(ANDROID_LOG_INFO, "xu", "Breathled1 fd != -1 after");	if (res < 0)	{		return JNI_FALSE;	}__android_log_print(ANDROID_LOG_INFO, "xu", "Breathled1  res > 0");	if(buf[0] == '1')	{	    return JNI_TRUE;	}	else	{	    return JNI_FALSE;	}    	}#ifdef _cplusplus}#endif//JNI register////////////////////////////////////////////////////////////////static const char *classPathName = "com/bird/smt_sw/MMINativeLib";static JNINativeMethod methods[] ={    {"device_test_led_r_on_jni",  "()Z", (void*)led_r_turn_on },    {"device_test_led_r_off_jni", "()Z", (void*)led_r_turn_off },    {"device_test_keypad_bk_turn_on_jni",  "()Z", (void*)keypad_bk_turn_on },    {"device_test_keypad_bk_turn_off_jni", "()Z", (void*)keypad_bk_turn_off },    {"device_test_get_barcode_jni", "()Ljava/lang/String;", (void*)barcode_bird },        {"BreathledStart", "()Z", (void*)BreathledStart },    {"BreathledStop", "()Z", (void*)BreathledStop },    {"Breathled1", "()Z", (void*)Breathled1 },    {"device_test_led_g_on_jni",  "()Z", (void*)led_g_turn_on },    {"device_test_led_g_off_jni", "()Z", (void*)led_g_turn_off },    {"device_test_led_b_on_jni",  "()Z", (void*)led_b_turn_on },    {"device_test_led_b_off_jni", "()Z", (void*)led_b_turn_off },};/* * Register several native methods for one class. */static int registerNativeMethods(JNIEnv* env, const char* className,                                 JNINativeMethod* gMethods, int numMethods){    jclass clazz;    clazz = env->FindClass(className);    if (clazz == NULL)    {      //  LOGE("Native registration unable to find class '%s'", className);        return JNI_FALSE;    }    if (env->RegisterNatives(clazz, gMethods, numMethods) < 0)    {     //   LOGE("RegisterNatives failed for '%s'", className);        return JNI_FALSE;    }    return JNI_TRUE;}/* * Register native methods for all classes we know about. * * returns JNI_TRUE on success. */static int registerNatives(JNIEnv* env){    if (!registerNativeMethods(env, classPathName,                               methods, sizeof(methods) / sizeof(methods[0])))    {        return JNI_FALSE;    }    return JNI_TRUE;}// ----------------------------------------------------------------------------/* * This is called by the VM when the shared library is first loaded. */typedef union{    JNIEnv* env;    void* venv;} UnionJNIEnvToVoid;jint JNI_OnLoad(JavaVM* vm, void* reserved){    UnionJNIEnvToVoid uenv;    uenv.venv = NULL;    jint result = -1;    JNIEnv* env = NULL;    //LOGI("JNI_OnLoad");    if (vm->GetEnv(&uenv.venv, JNI_VERSION_1_4) != JNI_OK)    {       // LOGE("ERROR: GetEnv failed");        goto bail;    }    env = uenv.env;    if (registerNatives(env) != JNI_TRUE)    {      //  LOGE("ERROR: registerNatives failed");        goto bail;    }    result = JNI_VERSION_1_4;bail:    return result;}